#!/usr/bin/env bash
set -e
### BEGIN INIT INFO
# Provides:          systemctl3.py service
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Systemctl3.py front-end script in Termux.
### END INIT INFO

# Set variables for the service
NAME=systemctl-init
PIDDIR=$PREFIX/var/run
PIDFILE=$PIDDIR/$NAME.pid

systemctl_file="systemctl"
systemctl_dir=("$HOME/.local/bin" "/usr/local/bin" "$PREFIX/usr/bin" "/bin")
for dir in "${systemctl_dir[@]}"; do
    if [ -n "$(find $dir -maxdepth 1 -iname "$systemctl_file" -type f -print -quit)" ]; then
        service="$dir/$systemctl_file"
        break
    fi
done
if [ -z $service ] ;then
  echo ${0##*/}: command not found: $systemctl_file
  return 1 
fi

monitor_status() {
  local monitor_name="$1"
  local monitor_status=""
  shift
  "$monitor_name" $@ >/dev/null
  if [ "$?" -eq 0 ]; then
      monitor_status="\033[37m[\033[0m\033[0;32m  OK  \033[0m\033[37m]"
      monitor_name="$(echo ${monitor_name:0:1} | tr '[:lower:]' '[:upper:]')${monitor_name:1}\033[0m"
      echo -e "$monitor_status $monitor_name $@"
  else
      monitor_status="\033[37m[\033[0m\033[0;31mFAILED\033[0m\033[37m]"
      monitor_name="Failed\033[0m $monitor_name"
      echo -e "$monitor_status $monitor_name $@" 1>&2
  fi
}

halt() {
  echo "Running systemctl halt to stop $NAME..."
  nohup $service halt > /dev/null &

  # Wait for the command to exit or timeout
  local I=0
  while [ $I -lt 10 ] && kill -0 "$PID" >/dev/null 2>&1; do
      sleep 1
      I=$((I + 1))
  done
}

if command -v start-stop-daemon >/dev/null 2>&1; then
    # Use start-stop-daemon to manage the service
    start() {
        start-stop-daemon --start --background --make-pidfile --pidfile "$PIDFILE" \
            --name "$NAME" --exec "$service" -- "init"
    }
    stop() {
        halt
        kill -15 $(cat $PIDFILE)
    }
else
    # Use shell script to manage the service
    start() {
        nohup $service init > /dev/null &
        echo $! > "$PIDFILE"
    }
    stop() {
        if [ -f "$PIDFILE" ]; then
            local PID=$(cat "$PIDFILE")
            if [ -n "$PID" ] && kill -0 "$PID" >/dev/null 2>&1; then
                halt                
                # Force kill the process after timeout
                kill -KILL "$PID" >/dev/null 2>&1
            fi
            rm "$PIDFILE"
        fi
    }
fi

restart() {
    stop
    start
}

# Check the status of the service
status() {
    echo "Service Name: $NAME"
    if [ -f "$PIDFILE" ]; then
        local PID=$(cat "$PIDFILE")
        if [ -n "$PID" ] && kill -0 "$PID" >/dev/null 2>&1; then
            echo "Process ID (PID): $PID"
            echo "Script Path: $service"
            ps -p "$PID" -o cmd=
            return
        fi
    fi
    echo "$NAME is not running."
}

# Handle the input arguments to determine which action to take
case "$1" in
    start)
        monitor_status start
        ;;
    stop)
        monitor_status stop
        ;;
    restart)
        monitor_status restart
        ;;
    status)
        status
        ;;
    *)
        echo "Usage: service {start|stop|restart|status}"
        exit 1
        ;;
esac

exit 0